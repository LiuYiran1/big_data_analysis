### 数据插值学习
- 插值类别（也可以直接填充）
  - 多项式插值
  - 分段线性插值
  - 样条插值
  - 最近邻插值
  - 局部加权插值（KNN、IDW等）
  - 基于模型的插值（ARIMA、机器学习等）
- 插值的时机和对象
  - 进行数据清洗后
  - 数据是时间序列或有序数值数据，缺失值有逻辑上的连续性
- 代码
```python
class Interpolator:
    def __init__(self, method="linear", group_cols=None, limit=None, fill_type=None):
        """
        插值类
        :param method: 插值方法 ('linear', 'time', 'spline', 'polynomial', ...)
        :param group_cols: 分组列名（list），如 ['city', 'device_id']
        :param limit: 限制最多填多少个连续缺失点
        :param fill_type: 填充方式 'ffill' 或 'bfill' 或 None
        """
        self.method = method
        self.group_cols = group_cols
        self.limit = limit
        self.fill_type = fill_type

    def process(self, group, target_col):
        """
        对单个分组的 target_col 进行插值或填充
        """
        group = group.copy()
        s = group[target_col]

        if self.fill_type == "ffill":
            s = s.ffill(limit=self.limit)
        elif self.fill_type == "bfill":
            s = s.bfill(limit=self.limit)
        else:
            s = s.interpolate(method=self.method, limit=self.limit, limit_direction="both")

        group[target_col + "_filled"] = s
        return group
        
    def fit_transform(self, df, target_col):
        """
        对df的target_col列进行插值或填充
        """
        data = df.copy()

        if self.group_cols:  # 要分组
            data = data.groupby(self.group_cols, group_keys=False).apply(
                lambda g: self.process(g, target_col)
            )
        else:  # 不分组
            data = self.process(data, target_col)

        return data.reset_index(drop=True)

```

### 将原始数据转换为特征向量
- 数值数据：无需转换
- 时间类型：转换为数值特征
- 类别数据：做编码
  - One-hot 编码（哑变量），把类别变成 0/1 向量
- 文本类型：分词 + 向量化
  - 分词
    - 英文：直接从空格处拆就行
    - 中文：使用jieba等库
  - 词袋模型
    1. 统计文本中的所有词及词频，建立一个词典列表
    2. 构建字符串对应的词袋向量
       - 词频：统计词的个数
       - 二值化：只考虑是否出现
       - TF-IDF
  - TF-IDF
    - 动机：为了能使得“高频常用词”和“低频罕见词”的处理更加优化，以确保两者对文本主题的影响正常
    - 词频(TF) : 衡量某个词在文档中的出现频率
      - `TF(t,d) = 某词在文档d中出现的次数/文档d中的总词数`
    - 逆文档频率(IDF) : 衡量一个词在所有文档中的区分能力
      - `IDF(t) = log(总文档数/(包含该词的文档数+1))`
    - TF-IDF: `TF-IDF(t,d) = TF(t,d) * IDF(t)` 
  - 词向量
- 代码（暂时没实现）